(()=>{"use strict";const e=(Math.sqrt(5)-1)/2;function t(t,r){return e*(r-t)}const r=[];for(let p=0;p<11;p++)r.push(.1*p);var a=(()=>(function(e){e.POWELL="Powells Method",e.PERMUTATION="Permutations"}(a||(a={})),a))(),o=(()=>(function(e){e.SES="Simple",e.DES="Double",e.TES="Triple"}(o||(o={})),o))();function n(e){return e.map(e=>Math.pow(e,2)).reduce((e,t)=>e+t)}function s(e){return e.map(e=>Math.abs(e)).reduce((e,t)=>e+t)/e.length}function l(e){return Math.sqrt(n(e)/e.length)}function c(e,t){const r=e.alpha,a={},c=t[0],u=[];u.push({index:1,forecast:c,error:t[1]-c});for(let o=2;o<t.length;o++){const e={},a=u[o-2];e.index=o,e.forecast=a.forecast+r*a.error,e.actual=t[o],e.error=t[o]-e.forecast,u.push(e)}const i=u[u.length-1],f=i.forecast+r*i.error;a.iterations=u,a.config=e;const h=[],p=e.futurePeriods?e.futurePeriods:1;for(let o=0;o<p;o++)h.push(f);return a.forecast=h,a.type=o.SES,a.errors=u.map(e=>e.error),a.MAD=s(a.errors),a.RMSE=l(a.errors),a.ChiSquared=n(a.errors),a}function u(e,t){const r=e.alpha,a=e.beta,c=t[1],u=c-t[0],i={index:2};i.forecast=c+u,i.actual=t[2],i.error=i.actual-i.forecast,i.level=r*i.actual+(1-r)*(u+c),i.trend=a*(i.level-c)+(1-a)*u;const f=[];f.push(i);for(let o=3;o<t.length;o++){const e={},n=f[o-3];e.index=o,e.forecast=n.level+n.trend,e.actual=t[o],e.error=e.actual-e.forecast,e.level=r*e.actual+(1-r)*(n.trend+n.level),e.trend=a*(e.level-n.level)+(1-a)*n.trend,f.push(e)}const h=f[f.length-1],p=e=>h.level+e*h.trend,d={};d.type=o.DES,d.iterations=f,d.config=e;const m=[],g=e.futurePeriods?e.futurePeriods:1;for(let o=1;o<=g;o++)m.push(p(o));return d.forecast=m,d.errors=f.map(e=>e.error),d.MAD=s(d.errors),d.RMSE=l(d.errors),d.ChiSquared=n(d.errors),d}function i(e,t){const r=e.m,a=e.alpha,c=e.beta,u=e.gamma,i=t.slice(0,r).reduce((e,t)=>e+t)/4,f=t.slice(0,r).map(e=>e/i),h=f.map(e=>{const t={};return t.season=e,t}),p={};p.actual=t[r],p.index=r,p.level=p.actual/f[0],p.trend=p.level-t[r-1]/f[r-1],p.season=u*(p.actual/p.level)+(1-u)*f[0],h.push(p);for(let o=r+1;o<t.length;o++){const e={};e.actual=t[o],e.index=o,e.level=a*(e.actual/h[o-r].season)+(1-a)*(h[o-1].level+h[o-1].trend),e.trend=c*(e.level-h[o-1].level)+(1-c)*h[o-1].trend,e.season=u*(e.actual/e.level)+(1-u)*h[o-r].season,e.forecast=(h[o-1].level+h[o-1].trend)*h[o-r].season,e.error=e.actual-e.forecast,h.push(e)}const d=h[h.length-1],m=(e,t,r)=>{const a=e+t-r*(1+Math.floor(t/r));return(d.level+t*d.trend)*h[a].season},g={};g.type=o.TES,g.iterations=h,g.config=e;const S=[],E=e.futurePeriods?e.futurePeriods:1;let M=h.length-1;for(let o=1;o<=E;o++)S.push(m(M,o,r));return g.forecast=S,g.errors=h.filter(e=>e.error).map(e=>e.error),g.MAD=s(g.errors),g.RMSE=l(g.errors),g.ChiSquared=n(g.errors),g}function f(e,t){const r={};return e.forEach((e,a)=>{r[e]=t[a]}),r}const h=["LOCATION","SKU"];addEventListener("message",({data:e})=>{const o=e,n={},s=o.forecastInOutArray.length;o.forecastInOutArray.forEach((e,l)=>{const p={};o.metricData.push(p),e.forecast=function(e,o,n){let s={},l=[],f={};f.alpha=function(e){const r=function(e){return function(t){return c(t,e).ChiSquared}}(e);return function(e,r,a,o=15){let n,s,l,c;for(let u=0;u<o;u++){const o=t(r,a);n=r+o,s=a-o,l=e(n),c=e(s),l<c?r=s:a=n}return(a+r)/2}(e=>r({alpha:e}),0,1)}(e),f.futurePeriods=n,s.ses=c(f,e),l.push(s.ses);let h=function(e){const t=function(e){return function(t){return u(t,e).ChiSquared}}(e);let o=[],n=0;r.forEach(e=>{r.forEach(r=>{let a={};a.currentCS=t({alpha:e,beta:r}),a.alpha=e,a.beta=r,a.iteration=n++,o.push(a)})});let s=o[0];for(let r=0;r<o.length;r++)o[r].currentCS<s.currentCS&&(s=o[r]);return{optimalIteration:s.iteration,optimalCS:s.currentCS,searchType:a.PERMUTATION,stepCount:o.length,alpha:s.alpha,beta:s.beta,steps:o,history:e}}(e);const p={};if(p.alpha=h.alpha,p.beta=h.beta,p.futurePeriods=n,s.des=u(p,e),l.push(s.des),e.length>o){let t=function(e,t){const o=function(e){return function(t){return i(t,e).ChiSquared}}(e);let n=[],s=0;r.forEach(e=>{r.forEach(a=>{r.forEach(r=>{let l={};l.currentCS=o({alpha:e,beta:a,gamma:r,m:t}),l.alpha=e,l.beta=a,l.gamma=r,l.iteration=s++,n.push(l)})})});let l=n[0];for(let r=0;r<n.length;r++)n[r].currentCS<l.currentCS&&(l=n[r]);return{optimalStepIteration:l.iteration,converged:!0,optimalCS:l.currentCS,searchType:a.PERMUTATION,stepCount:n.length,alpha:l.alpha,beta:l.beta,gamma:l.gamma,steps:n,history:e,m:t}}(e,o);s.tes=i({alpha:t.alpha,beta:t.beta,gamma:t.gamma,m:o,futurePeriods:n},e),l.push(s.tes)}{let e=l[0];l.forEach(t=>{t.MAD<e.MAD&&(e=t)});const t={};return t.optimal=e,t.results=s,t}}(e.history,o.forecastTimeMeta.m,o.forecastLength);const{type:d,MAD:m,RMSE:g}=e.forecast.optimal;p.location=e.keys[0],p.sku=e.keys[1],p.type=d,p.mad=m.toFixed(2),p.rmse=g.toFixed(2);const{alpha:S,beta:E,gamma:M}=e.forecast.optimal.config;p.alpha=S?S.toFixed(2):"NA",p.beta=E?E.toFixed(2):"NA",p.gamma=M?M.toFixed(2):"NA";const v=e.forecast.optimal.forecast.map(e=>e.toFixed(o.precision)),b=f(o.forecastTimeHeaders,v),C=f(h,e.keys),y=Object.assign(Object.assign({},C),b);o.forecastData.push(y),n.percentage=Math.floor(l/s*100),n.complete=l==s-1,n.complete?(n.HFD=o,postMessage(n)):postMessage(n)})})})();